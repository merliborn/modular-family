-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A type for modular arithmetic with parametrized modular
--   
--   A type for modular arithmetic with parametrized modular
@package modular-family
@version 0.2.0.0


-- | Exceptions for <tt>FinNat</tt> data types
module Data.Modular.Some.Exception
data FinNatException
NonPositiveUpperBound :: FinNatException
ValueOverflow :: FinNatException
ValueUnderflow :: FinNatException
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a
instance GHC.Classes.Ord Data.Modular.Some.Exception.FinNatException
instance GHC.Classes.Eq Data.Modular.Some.Exception.FinNatException
instance GHC.Exception.Type.Exception Data.Modular.Some.Exception.FinNatException
instance GHC.Show.Show Data.Modular.Some.Exception.FinNatException


-- | A type for finite natural numbers (experimental)
module Data.Modular.Some

-- | A type of natural numbers at most <tt>n</tt>
data FinNat (n :: Nat)

-- | Pattern/setter for <a>FinNat</a> data
--   
--   As an expression, <tt>FNat i n</tt> throws exception if (1) <tt>i</tt>
--   is larger than bound (<tt>ValueOverflow</tt>) or (2) <tt>n</tt> is
--   less than or equal to 0 (<tt>NonPositiveUpperBound</tt>).
pattern FNat :: Natural -> SNat n -> FinNat n

-- | <pre>
--   &gt;&gt;&gt; fromFinNat zero
--   0
--   </pre>
zero :: forall n. (KnownNat n, (1 :: Nat) <= n) => FinNat n
boundSing :: FinNat n -> SNat n
upcast :: forall m n. (KnownNat n, KnownNat m, m <= n) => FinNat m -> FinNat n
data SomeFinNat
someFinNat :: (Integral a, Integral b) => a -> b -> Maybe SomeFinNat
toMaybeFinNat :: forall a (n :: Nat). (Integral a, KnownNat n) => a -> Maybe (FinNat n)

-- | A class <a>CompatibleWithFNat</a> is a class for conversion with
--   <a>FNat</a> types, and a class for two methods: <a>fromFinNat</a> and
--   <a>toFinNat</a>.
class CompatibleWithFNat (n :: Nat) a
fromFinNat :: CompatibleWithFNat n a => FinNat n -> a
toFinNat :: (CompatibleWithFNat n a, KnownNat n) => a -> FinNat n
type FinNat8 = FinNat (0x100 :: Nat)
type FinNat16 = FinNat (0x10000 :: Nat)
type FinNat32 = FinNat (0x100000000 :: Nat)
type FinNat64 = FinNat (0x10000000000000000 :: Nat)
instance Data.Modular.Some.CompatibleWithFNat n GHC.Num.Natural.Natural
instance Data.Modular.Some.CompatibleWithFNat 256 GHC.Word.Word8
instance Data.Modular.Some.CompatibleWithFNat 65536 GHC.Word.Word16
instance Data.Modular.Some.CompatibleWithFNat 4294967296 GHC.Word.Word32
instance Data.Modular.Some.CompatibleWithFNat 18446744073709551616 GHC.Word.Word64
instance GHC.Classes.Eq (Data.Modular.Some.FinNat n)
instance GHC.Classes.Ord (Data.Modular.Some.FinNat n)
instance (GHC.TypeNats.KnownNat n, 1 Data.Type.Ord.<= n) => GHC.Enum.Bounded (Data.Modular.Some.FinNat n)
